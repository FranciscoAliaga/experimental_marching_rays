shader_type canvas_item;

#include "./new_shader.gdshaderinc"

// x horizontal
// y vertical
// z forward

uniform vec3 camera_pos;
uniform vec3 camera_angle;

uniform int x_pixels;
uniform int y_pixels;

uniform mat3 camera_rotation;

uniform vec3 floor_color : source_color;
uniform vec3 sky_color : source_color;
uniform vec3 fog_color : source_color;
uniform float fog_pond;

const float dh = 0.001;

#define RAY_JUMPS 3

// takes an uv coordinate from the screen renderer and
// returns the normalized ray.
vec3 ray(vec2 uv){
	// center uv
	vec2 uuvv = uv - vec2(0.5,0.5);
	// invert y coordinate
	uuvv.y *= -1.;
	// pass a ray through the {(x,y,z) : z=1} plane coming from the origin
	vec3 rd = vec3(uuvv,1.);
	// transform it according to camera
	vec3 c = cos(camera_angle);
	vec3 s = sin(camera_angle);
	rd = camera_rotation * rd;
	// return answer
	return normalize(rd);
}

float get_sdf(vec3 pos, float t){
	vec3 center = vec3(0,0.,5.);
	float ans = cube_sdf(pos,center,.7);
	ans = max(ans,-sphere_sdf(pos,center+vec3(-0.2,0.2,-0.2),.9));
	ans = min(ans,cube_sdf(pos,center+1.*vec3(0.,3.-1.8*sin(t),0.),.3));
	
	int N = 10;
	float r = 2.;
	for(int i = 0; i <N ; i++ ){
		float angle = 2.*PI*float(i)/float(N);
		vec3 c_center = center + vec3(0.,3.,0.);
		vec3 displacement = r*vec3(cos(angle+t),0.,sin(angle+t));
		ans = min(ans,sphere_sdf(pos,c_center+displacement,0.3));
	}
	
	return ans;
}

vec3 get_color(vec3 pos,float t){
	if (far_away(pos,100.)){
		if (pos.y > 0.) return sky_color;
		else return floor_color;
	}
	if (get_sdf(pos,t)<=0.001){
		return vec3(
			0.7+0.3*cos(t),
			0.7+0.3*cos(t+0.3333 * PI),
			0.7+0.3*cos(t+0.6666 * PI)
		);
//		return vec3(0.3,0.2,8.);
	}
}


vec3 get_normal(vec3 pos,float t){
	if(far_away(pos,100.)){
		return vec3(0.0);
	}
	float dx = get_sdf(pos+vec3(dh,0.,0.),t) - get_sdf(pos,t) ;
	float dy = get_sdf(pos+vec3(0.,dh,0.),t) - get_sdf(pos,t) ;
	float dz = get_sdf(pos+vec3(0.,0.,dh),t) - get_sdf(pos,t) ;
	return vec3(dx/dh,dy/dh,dz/dh);
}



vec4 ray_marching(vec3 pos, vec3 ray, float t){
	float depth = 0.;
	int steps = 0;
	float d = get_sdf(pos, t)+0.01;
	do {
		depth += d;
		pos = pos + ray * d;
		d = get_sdf(pos,t);
		steps++;
	} while(abs(d) > 0.001 && steps < 50);
	vec4 res; // = (pos, depth)
	res.rgb = pos;
	res.a = depth;
	return res;
}

void fragment() {
	// first ray march
	vec3 ro = camera_pos;
	vec3 rd = ray(pixel_uv(UV,ivec2(x_pixels,y_pixels)));
	vec4 ray_march_result = ray_marching(ro,rd,TIME);
	vec3  first_hit    = ray_march_result.rgb;
	float first_depth  = ray_march_result.a;
	vec3  first_color  = get_color(first_hit,TIME);
	vec3  first_normal = get_normal(first_hit,TIME);
	// second ray march
	ro = first_hit;
	rd = reflect_vector_plane(rd,first_normal);
	ray_march_result = ray_marching(ro,rd,TIME);
	vec3  second_hit    = ray_march_result.rgb;
	float second_depth  = ray_march_result.a;
	vec3  second_color  = get_color(second_hit,TIME);
	vec3  second_normal = get_normal(second_hit,TIME);
	
	// color calculation
	vec3 color = 0.8*first_color + 0.2*second_color;
	vec3 fog  = 0.5 * first_color + 0.5 * fog_color; 
	
	float vdepth = first_depth;
	float ldepth = 1./(fog_pond+vdepth);
	
	color = (fog_pond*color + vdepth * fog)*ldepth;
	
	COLOR.rgb = color;
	
	if(far_away(first_hit,100.)){
		COLOR.rgb = first_color;
	}
}

